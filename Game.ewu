$version 11.00

$rect <20,220,220,260>
$output false
class GameField : Core::Group
{
  $rect <271,0,450,40>
  inherited method Init()
  {
    var int32 col = 0;
    var int32 row = 0;

    for ( row = 0; row < 3; row++ ){
      for ( col = 0; col < 3;  col++ ) {
        aFieldItems[ row, col ].linkToCurrentPlayer = ^pCurrentPlayer;
        aFieldItems[ row, col ].linkToCounter = ^pCounter; }   }

                                                           
    vCurrentPlayerTitle.String = "Current Player: " + pCurrentPlayer.Name ;
    vNextPlayerTitle.String = "Next Player: " + pNextPlayer.Name ;


    /*
    aValueState[0] = ^aFieldItems[0,0].FieldValue + ^aFieldItems[0,1].FieldValue + ^aFieldItems[0,2].FieldValue;
    aValueState[1] = ^aFieldItems[1,0].FieldValue + ^aFieldItems[1,1].FieldValue + ^aFieldItems[1,2].FieldValue;
    aValueState[2] = ^aFieldItems[2,0].FieldValue + ^aFieldItems[2,1].FieldValue + ^aFieldItems[2,2].FieldValue;
    // all columns
    aValueState[3] = ^aFieldItems[0,0].FieldValue + ^aFieldItems[1,0].FieldValue + ^aFieldItems[2,0].FieldValue;
    aValueState[4] = ^aFieldItems[0,1].FieldValue + ^aFieldItems[1,1].FieldValue + ^aFieldItems[2,1].FieldValue;
    aValueState[5] = ^aFieldItems[0,2].FieldValue + ^aFieldItems[1,2].FieldValue + ^aFieldItems[2,2].FieldValue;
    // all diagonals
    aValueState[6] = ^aFieldItems[0,0].FieldValue + ^aFieldItems[1,1].FieldValue + ^aFieldItems[2,2].FieldValue;
    aValueState[7] = ^aFieldItems[2,0].FieldValue + ^aFieldItems[1,1].FieldValue + ^aFieldItems[0,2].FieldValue; */




  }

  $rect <-10,350,190,390>
  inherited property Bounds = <0,0,240,320>;

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <94,235>;
    preset Point1 = <94,85>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <144,235>;
    preset Point1 = <144,85>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <194,135>;
    preset Point1 = <44,135>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <194,185>;
    preset Point1 = <44,185>;
    preset Width = 2;
  }

  $rect <260,60,460,100>
  array Game::FieldItem aFieldItems[ 3,3 ] =
  (
    Default[0, 0] = vField_00;
    Default[0, 1] = vField_01;
    Default[0, 2] = vField_02;
    Default[1, 0] = vField_10;
    Default[1, 1] = vField_11;
    Default[1, 2] = vField_12;
    Default[2, 0] = vField_20;
    Default[2, 1] = vField_21;
    Default[2, 2] = vField_22;
  );

  $rect <20,20,160,60>
  object Game::FieldItem vField_00
  {
    preset Bounds = <44,85,94,135>;
    preset Enabled = true;
    preset linkToCurrentPlayer = ^pCurrentPlayer;
    preset linkToCounter = ^pCounter;
    preset FieldValue = 0;
  }

  $rect <20,20,160,60>
  object Game::FieldItem vField_01
  {
    preset Bounds = <94,85,144,135>;
    preset FieldContent;
    preset linkToCurrentPlayer = ^pCurrentPlayer;
    preset linkToCounter = ^pCounter;
    preset FieldValue = 0;
  }

  $rect <20,20,160,60>
  object Game::FieldItem vField_02
  {
    preset Bounds = <144,85,194,135>;
    preset linkToCurrentPlayer = ^pCurrentPlayer;
    preset linkToCounter = ^pCounter;
  }

  $rect <20,20,160,60>
  object Game::FieldItem vField_10
  {
    preset Bounds = <44,135,94,185>;
    preset linkToCurrentPlayer = ^pCurrentPlayer;
    preset linkToCounter = ^pCounter;
  }

  $rect <20,20,160,60>
  object Game::FieldItem vField_11
  {
    preset Bounds = <94,135,144,185>;
    preset linkToCurrentPlayer = ^pCurrentPlayer;
    preset linkToCounter = ^pCounter;
  }

  $rect <20,20,160,60>
  object Game::FieldItem vField_12
  {
    preset Bounds = <144,135,194,185>;
    preset linkToCurrentPlayer = ^pCurrentPlayer;
    preset linkToCounter = ^pCounter;
  }

  $rect <20,20,160,60>
  object Game::FieldItem vField_20
  {
    preset Bounds = <44,185,94,235>;
    preset linkToCurrentPlayer = ^pCurrentPlayer;
    preset linkToCounter = ^pCounter;
  }

  $rect <20,20,160,60>
  object Game::FieldItem vField_21
  {
    preset Bounds = <95,185,145,235>;
    preset linkToCurrentPlayer = ^pCurrentPlayer;
    preset linkToCounter = ^pCounter;
  }

  $rect <20,20,160,60>
  object Game::FieldItem vField_22
  {
    preset Bounds = <144,185,194,235>;
    preset linkToCurrentPlayer = ^pCurrentPlayer;
    preset linkToCounter = ^pCounter;
  }

  $rect <260,350,480,390>
  method void mChangeCurrentPlayer()
  {
    if ( pCounter%2 == 1) {
      pCurrentPlayer = Player2;
      pNextPlayer = Player1;
      isP1_Led = false;  }
    else{
      pCurrentPlayer = Player1;
      pNextPlayer = Player2;
      isP1_Led = true;}

  }

  $rect <471,0,671,40>
  object Game::Players Player1
  {
    preset Value = 1;
  }

  $rect <670,0,870,40>
  object Game::Players Player2
  {
    preset Name = "P2";
    preset Icon = "O";
    preset Value = 2;
  }

  $rect <20,20,160,60>
  object Views::Text vCounter
  {
    preset Bounds = <7,3,44,33>;
    preset String = "0";
    preset Font = Resources::FontLarge;
  }

  $rect <670,180,870,220>
  property int32 pCounter;

  $rect <670,220,870,260>
  onset pCounter
  {
    // The value doesn't change - nothing to do.
    if ( pure pCounter == value )
      return;

    // Remember the property's new value.
    pure pCounter = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.


    mUpdateValueState();
    mCheckIfWon();
    mChangeCurrentPlayer();
    vCounter.String = pCounter;
    // 

  }

  $rect <670,260,870,300>
  onget pCounter
  {
    return pure pCounter;
  }

  $rect <940,220,1140,260>
  slot TestMethod
  {
    CounterUpper();

    //fieldContentArray[0,0].FieldContent = CurrentPlayer.PlayerIcon;

    mChangeCurrentPlayer();
    //vField_00.CurrentPlayer.PlayerIcon = pCurrentPlayer.PlayerIcon;
    //vField_01.CurrentPlayer.Icon = pCurrentPlayer.Icon;
    //vField_02.CurrentPlayer.PlayerIcon = pCurrentPlayer.PlayerIcon;

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton TestButton
  {
    preset Bounds = <179,3,240,28>;
    preset OnPress = TestMethod;
    preset Label = "Test";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <471,40,671,80>
  property Game::Players pCurrentPlayer = Player1;

  $rect <471,80,671,120>
  onset pCurrentPlayer
  {
    // The value doesn't change - nothing to do.
    if ( pure pCurrentPlayer == value )
      return;

    // Remember the property's new value.
    pure pCurrentPlayer = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    vCurrentPlayerTitle.String = "Current Player: " + pCurrentPlayer.Name ;


  }

  $rect <471,120,671,160>
  onget pCurrentPlayer
  {
    return pure pCurrentPlayer;
  }

  $rect <20,20,160,60>
  object Views::Text vCurrentPlayerTitle
  {
    preset Bounds = <0,38,119,68>;
    preset String = "Current Player: ";
    preset Font = Resources::DefaultFont;
  }

  $rect <940,260,1140,300>
  method void CounterUpper()
  {
    pCounter += 1;
  }

  $rect <670,40,870,80>
  property Game::Players pNextPlayer = Player2;

  $rect <670,80,870,120>
  onset pNextPlayer
  {
    // The value doesn't change - nothing to do.
    if ( pure pNextPlayer == value )
      return;

    // Remember the property's new value.
    pure pNextPlayer = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    vNextPlayerTitle.String = "Next Player: " + pNextPlayer.Name ;
  }

  $rect <670,120,870,160>
  onget pNextPlayer
  {
    return pure pNextPlayer;
  }

  $rect <20,20,160,60>
  object Views::Text vNextPlayerTitle
  {
    preset Bounds = <119,38,240,68>;
    preset String = "Next Player: ";
    preset Font = Resources::DefaultFont;
  }

  $rect <470,180,670,220>
  property string pMsgText;

  $rect <470,220,670,260>
  onset pMsgText
  {
    // The value doesn't change - nothing to do.
    if ( pure pMsgText == value )
      return;

    // Remember the property's new value.
    pure pMsgText = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    vMsgText.String = pMsgText;
  }

  $rect <470,260,670,300>
  onget pMsgText
  {
    return pure pMsgText;
  }

  $rect <20,20,160,60>
  object Views::Text vMsgText
  {
    preset Bounds = <-1,11,239,41>;
    preset String = "";
    preset Font = Resources::FontSmall;
  }

  $rect <940,340,1140,380>
  array int32 aValueState[ 8 ] =
  (
    Default[0] = ;
    Default[1] = ;
    Default[2] = 0;
    Default[3] = 0;
    Default[4] = 0;
    Default[5] = ;
    Default[6] = ;
    Default[7] = ;
  );

  $rect <470,350,670,390>
  method void mCheckIfWon()
  {
    var int32 col;
    var int32 row;
    //var bool aWin = false;
    var int32 fieldSum;

    /*if (aFieldItems[0,0].FieldValue == 0 || aFieldItems[0,1].FieldValue == 0 || aFieldItems[0,2].FieldValue == 0 ){} 
    else{ aValueState[0] = aFieldItems[0,0].FieldValue + aFieldItems[0,1].FieldValue + aFieldItems[0,2].FieldValue;
          aWin = checkWhoWon(aValueState[0]);
         } */

    /*  USING values */
    // checking rows
    for ( row = 0; row < 3; row++ ){ 
      if (aFieldItems[row,0].FieldValue == 0 || aFieldItems[row,1].FieldValue == 0 || aFieldItems[row,2].FieldValue == 0 ){} 
      else{ aValueState[row] = aFieldItems[row,0].FieldValue + aFieldItems[row,1].FieldValue + aFieldItems[row,2].FieldValue;
            hasWon = mCheckWhoWon(aValueState[row]);
           } 
    }
    // checking columns
    for ( col = 0; col < 3;  col++ ){
      if (aFieldItems[0, col].FieldValue == 0 || aFieldItems[1, col].FieldValue == 0 || aFieldItems[2, col].FieldValue == 0 ){} 
      else{ aValueState[row] = aFieldItems[0, col].FieldValue + aFieldItems[1, col].FieldValue + aFieldItems[2, col].FieldValue;
            hasWon = mCheckWhoWon(aValueState[row]);
           }
    }
    // checking diagonals
    if (aFieldItems[0,0].FieldValue == 0 || aFieldItems[1,1].FieldValue == 0 || aFieldItems[2,2].FieldValue == 0 ){} 
    else{ fieldSum = aFieldItems[0,0].FieldValue + aFieldItems[1,1].FieldValue + aFieldItems[2,2].FieldValue;
          hasWon = mCheckWhoWon(fieldSum);
         }
    if (aFieldItems[2,0].FieldValue == 0 || aFieldItems[1,1].FieldValue == 0 || aFieldItems[0,2].FieldValue == 0 ){} 
    else{ fieldSum = aFieldItems[2,0].FieldValue + aFieldItems[1,1].FieldValue + aFieldItems[0,2].FieldValue;
          hasWon = mCheckWhoWon(fieldSum);
         }

      
  }

  $rect <660,350,860,390>
  method bool mCheckWhoWon( arg int32 aValueSum )
  {
    switch (aValueSum){
      case 3: {deactivateTouch(); pMsgText = Player1.Name + " has won!"; Player1.TotalWins += 1; notifyobservers Player1; return true;}
      case 6: {deactivateTouch(); pMsgText = Player2.Name + " has won!"; Player2.TotalWins += 1; notifyobservers Player2; return true;}
      default: return false;  
    }
  }

  $rect <940,300,1140,340>
  method void mUpdateValueState()
  {
    /* ALL for Debugging Purpose
     * updates the sum of each row, columns and diagonal
     * updates the view  
     */
    // all rows
    //aValueState[0] = vField_00.FieldValue + vField_01.FieldValue + vField_02.FieldValue;
    aValueState[0] = aFieldItems[0,0].FieldValue + aFieldItems[0,1].FieldValue + aFieldItems[0,2].FieldValue;
    aValueState[1] = aFieldItems[1,0].FieldValue + aFieldItems[1,1].FieldValue + aFieldItems[1,2].FieldValue;
    aValueState[2] = aFieldItems[2,0].FieldValue + aFieldItems[2,1].FieldValue + aFieldItems[2,2].FieldValue;
    // all columns
    aValueState[3] = aFieldItems[0,0].FieldValue + aFieldItems[1,0].FieldValue + aFieldItems[2,0].FieldValue;
    aValueState[4] = aFieldItems[0,1].FieldValue + aFieldItems[1,1].FieldValue + aFieldItems[2,1].FieldValue;
    aValueState[5] = aFieldItems[0,2].FieldValue + aFieldItems[1,2].FieldValue + aFieldItems[2,2].FieldValue;
    // all diagonals
    aValueState[6] = aFieldItems[0,0].FieldValue + aFieldItems[1,1].FieldValue + aFieldItems[2,2].FieldValue;
    aValueState[7] = aFieldItems[2,0].FieldValue + aFieldItems[1,1].FieldValue + aFieldItems[0,2].FieldValue;

    rr0.String = aValueState[0];
    rr1.String = aValueState[1];
    rr2.String = aValueState[2];
    rc0.String = aValueState[3];
    rc1.String = aValueState[4];
    rc2.String = aValueState[5];
    rd0.String = aValueState[6];
    rd1.String = aValueState[7];


      


  }

  $rect <20,20,160,60>
  object Views::Text rc0
  {
    preset Bounds = <44,58,94,88>;
    preset String = 0;
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text rr0
  {
    preset Bounds = <194,85,220,133>;
    preset String = 0;
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text rr1
  {
    preset Bounds = <194,135,220,183>;
    preset String = 0;
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text rr2
  {
    preset Bounds = <194,187,220,235>;
    preset String = 0;
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text rc1
  {
    preset Bounds = <95,58,145,88>;
    preset String = 0;
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text rc2
  {
    preset Bounds = <144,58,194,88>;
    preset String = 0;
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text rd1
  {
    preset Bounds = <194,58,219,88>;
    preset String = 0;
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text rd0
  {
    preset Bounds = <19,58,44,88>;
    preset String = 0;
    preset Font = Resources::DefaultFont;
  }

  // Debugging Purpose
  note group Note
  {
    attr Bounds = <919,180,1159,389>;
  }

  // will this be shown?
  $rect <260,170,460,210>
  property bool hasWon = false;

  $rect <260,210,460,250>
  onset hasWon
  {
    // The value doesn't change - nothing to do.
    if ( pure hasWon == value )
      return;

    // Remember the property's new value.
    pure hasWon = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.

    // deactivate the fields to prevent further playing after a win
       

    // if all the fields are filled and no winner exist = text displays a DRAW
    //if (!hasWon && (pCounter==9)) {pMsgText = "It's a DRAW!"; Remove( vCurrentPlayerTitle); Remove( vNextPlayerTitle);}

    if (hasWon && pCounter == 9) {Remove( vCurrentPlayerTitle); Remove( vNextPlayerTitle);}





    /*
    if (hasWon){
      deactivateTouch();
    }      */

      

  }

  $rect <260,250,460,290>
  onget hasWon
  {
    return pure hasWon;
  }

  $rect <470,390,670,430>
  method void deactivateTouch()
  {
    var int32 col;
    var int32 row;

    for ( row = 0; row < 3; row++ )
      for ( col = 0; col < 3;  col++ )
        aFieldItems[ row, col ].SimpleTouchHandler.Enabled = false;   
  }

  $rect <20,20,160,60>
  object Views::Text vMsgText1
  {
    preset Bounds = <0,38,240,68>;
    preset String = "";
    preset Font = Resources::FontSmall;
  }

  $rect <919,20,1119,60>
  var bool isP1_Led = true;
}

// To do:
// 
// - Open the 'Application' component for editing. It represents your entire GUI. \
// Use widgets, views, event handlers and effects from the Gallery to assemble there \
// your desired GUI look and feel.
// 
// - Create your own GUI components, widgets, panels, etc. The Gallery folder 'Component \
// Templates' contains for this purpose various templates you can simply add to the \
// unit and thus start your own component development.
// 
// - You can add your own bitmap and font resources to the unit. Use the templates \
// 'Bitmap Resource' and 'Font Resource' from the Gallery folder 'Resources' for \
// this purpose.
// 
// - You can add here also constants to store e.g. multilingual text fragments. Use \
// for this purpose the template 'Constant' from the Gallery folder 'Chora'.
// 
// - To add an interface for communication with the target device use the template \
// 'Device Interface' from the Gallery folder 'Device'.
note legend Note1
{
  attr Bounds = <990,170,1270,480>;
}

// This is a font resource.
$rect <490,279,690,319>
$output false
resource Resources::Font Font
{
  attr fontname FontName = Arial;
  attr fontheight Height = 32;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

$rect <240,610,440,650>
inline Inline
{
  /*

    TO DO:

    Include external header files or add type and function declarations needed
    in the implementation of Application::DeviceClass. For example:

      #include "DeviceDriver.h"

      #include "your_middleware_api.h"

      void Your_Middleware_Some_Function( int aSomeArg );

  */
}

$rect <20,610,220,650>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <30,80,230,120>
  inherited method Done()
  {
    // The following section is intended to perform de-initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         de-initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. de-register the object from the middleware if you have registered it
         beforehand.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           de-initialization steps. For example, you invoke some 'C' function:

             YourDevice_DeInitialize();

           IMPORTANT:
           ----------

           The variable 'thisObject' represents the actually de-initialized instance of the
           Application::DeviceClass. If you have stored this object at the initialization
           time (in the 'Init' method) in some global C variable or registered it by the
           middleware, it is important to perform now the opposite operation. Set the
           global variable to NULL or de-register 'thisObject' object from the middleware.
           
        */
      }
    $endif
  }

  $rect <30,40,230,80>
  inherited method Init()
  {
    // The following section is intended to perform initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. register the object by the middleware as receiver of events, etc.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           initialization steps. For example, you invoke some 'C' function:

             YourDevice_Initialize();

           The variable 'thisObject' represents the actually initialized instance of the
           Application::DeviceClass. You can store this variable e.g. in the middleware
           and use it whenever the middleware needs to notify the GUI application about
           some state alternation or events. In this manner, the middleware will be able
           to invoke methods of the interface device object.

           For example, you can store 'thisObject' in some global C variable:

             // Declaration of the global C variable
             XObject theDeviceObject;

             // Store the instance in the global variable
             theDeviceObject = thisObject;

           Later use the global variable e.g. to provide the GUI application with events:

             ApplicationDeviceClass__TriggerSomeEvent( theDeviceObject );

           IMPORTANT:
           ----------

           If you store 'thisObject' for later use, don't forget to implement the opposite
           operation in the method 'Done'. Concrete, 'Done' should set the global variable
           again to the value NULL.

        */
      }
    $endif
  }

  // Device classes are assembled from 'Commands', 'Properties' and 'System Events'. \
  // For this purpose use the following prepared templates from the Gallery folder \
  // 'Device':
  // 
  // Command - method to trigger actions in the underlying device or query data from \
  // the device.
  // 
  // Property - variable to represent or modify a setting or state value existing \
  // within the underlying device.
  // 
  // System Event - represents an event or notifications the underlying device may \
  // report.
  // 
  // For more details please visit: https://doc.embedded-wizard.de/device-class-and-device-driver
  note legend Note4
  {
    attr Bounds = <10,230,1100,400>;
  }

  // The method 'Init' is executed just in the moment when new instance of 'Application::DeviceClass' \
  // is created. It is suitable to:
  // - initialize the hardware represented by the interface.
  // - register the instance by the middleware to receive updates and events.
  // - open files, network connections or other system resources needed by the interface.
  // 
  // The method 'Done' is executed just in the moment when an instance of 'Application::DeviceClass' \
  // is disposed. It is suitable to:
  // - de-initialize the underlying hardware.
  // - de-register the instance from the underlying middleware.
  // - close files, network connections and other no longer needed system resources.
  // 
  // If your application case doesn't need the initialization or de-initialization, \
  // feel free to delete the methods 'Init' or/and 'Done'.
  note legend Note3
  {
    attr Bounds = <320,0,1100,220>;
  }

  note arrow Note2
  {
    attr Point1 = <250,50>;
    attr Point2 = <320,50>;
  }

  // Constructor and Destructor
  note group Note1
  {
    attr Bounds = <10,0,250,140>;
  }
}

$rect <20,660,220,700>
autoobject Game::DeviceClass Device;

// Device Interface
note group Note2
{
  attr Bounds = <10,550,940,900>;
}

// The class 'Application::DeviceClass' implements the interface between the GUI \
// application and the device. Within the class you can react to system events sent \
// by the device, exchange data with the device or send commands to the device. You \
// are completely free in the design of this interface.
// 
// The object 'Device' represents the instance of the device interface. It exists \
// for your convenience. As an autoobject it is globally available for all GUI components \
// within your project.
// 
// The inline code member allows you to include external header files or add type \
// definitions needed by the implementation of 'Application::DeviceClass'.
// 
// More details inside the members.
// See also: https://doc.embedded-wizard.de/device-class-and-device-driver
note legend Note
{
  attr Bounds = <480,610,930,880>;
}

$rect <990,490,1190,530>
$output false
autoobject Views::Group Group
{
  preset Bounds = <0,0,100,100>;
}

// Screens
note group Note3
{
  attr Bounds = <10,140,230,410>;
}

$rect <251,180,451,220>
$output false
class FieldItem : Core::Group
{
  $rect <-60,109,140,149>
  inherited method Init()
  {
    // TO DO: Write your code here ... 
    pCurrentPlayer = new Game::Players;
    pCurrentPlayer.Icon = "D";
    pCurrentPlayer.Name = "PD";
    pCurrentPlayer.Value = 6;
  }

  $rect <-60,70,140,110>
  inherited property Bounds = <0,0,50,50>;

  $rect <-60,190,140,230>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-60,150,140,190>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );


    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <50,0>;
    preset Point2 = <50,50>;
    preset Point1 = <0,50>;
    preset OnPress = OnTouchFieldEvent;
  }

  $rect <190,80,390,120>
  property string FieldContent;

  $rect <190,120,390,160>
  onset FieldContent
  {
    // The value doesn't change - nothing to do.
    if ( pure FieldContent == value )
      return;

    // Remember the property's new value.
    pure FieldContent = value;

    // TO DO:
    //  
    // Now you can handle the alternation of the property.

    // it updates the vFieldContent to FieldContent
    vFieldContent.String = FieldContent;
    // disable touchhandler after assigning once.
    //SimpleTouchHandler.Enabled = false;
  }

  $rect <190,160,390,200>
  onget FieldContent
  {
    return pure FieldContent;
  }

  $rect <20,20,160,60>
  object Views::Text vFieldContent
  {
    preset Bounds = <0,1,50,50>;
    preset String = "";
    preset Font = Resources::FontExtraLarge;
  }

  $rect <180,210,380,250>
  property int32 FieldValue;

  $rect <180,250,380,290>
  onset FieldValue
  {
    // The value doesn't change - nothing to do.
    if ( pure FieldValue == value )
      return;

    // Remember the property's new value.
    pure FieldValue = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    //linkToCounter^ = (linkToCounter^) + 1;
  }

  // this slot method is triggered when player touch the fielditem
  $rect <90,0,290,40>
  slot OnTouchFieldEvent
  {
    //trace "FieldItem touched";
    pCurrentPlayer = linkToCurrentPlayer^;
    FieldContent = pCurrentPlayer.Icon;
    FieldValue = pCurrentPlayer.Value; 

    // disable touchhandler after triggered once
    SimpleTouchHandler.Enabled = false;

    // Add to Counter
    linkToCounter^ = (linkToCounter^) + 1;




  }

  $rect <-58,240,142,280>
  object Game::Players DefaultPlayer
  {
    preset Name = "PD";
    preset Icon = "D";
    preset Value = 6;
  }

  $rect <420,200,620,240>
  property ^Game::Players linkToCurrentPlayer = ^pCurrentPlayer;

  $rect <420,70,620,110>
  property ^int32 linkToCounter = ^DefaultCounter;

  $rect <420,110,620,150>
  onset linkToCounter
  {
    // The value doesn't change - nothing to do.
    if ( pure linkToCounter == value )
      return;

    // Remember the property's new value.
    pure linkToCounter = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <420,150,620,190>
  onget linkToCounter
  {
    return pure linkToCounter;
  }

  $rect <-60,290,140,330>
  property int32 DefaultCounter = 0;

  $rect <-58,326,142,366>
  property Game::Players pCurrentPlayer;

  $rect <420,240,620,280>
  onset linkToCurrentPlayer
  {
    // The value doesn't change - nothing to do.
    if ( pure linkToCurrentPlayer == value )
      return;

    // Remember the property's new value.
    pure linkToCurrentPlayer = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <420,280,620,320>
  onget linkToCurrentPlayer
  {
    return pure linkToCurrentPlayer;
  }

  $rect <180,290,380,330>
  onget FieldValue
  {
    return pure FieldValue;
  }
}

$rect <490,489,690,529>
$output false
autoobject Views::Image field_icon_sun
{
  preset Bounds = <0,0,50,50>;
  preset Color = Game::Nude;
  preset FrameNumber = 20;
  preset Bitmap = Resources::SymbolIconsMedium;
}

$rect <490,450,690,490>
$output false
autoobject Views::Image field_icon_moon
{
  preset Bounds = <0,0,50,50>;
  preset Color = Game::Nude;
  preset FrameNumber = 21;
  preset Bitmap = Resources::SymbolIconsMedium;
}

$rect <490,231,690,271>
$output false
resource Resources::Bitmap field_icon_cross
{
  attr bitmapfile FileName = C:\Users\seren\Downloads\field_icon_cross.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <490,190,690,230>
$output false
resource Resources::Bitmap field_icon_circle
{
  attr bitmapfile FileName = C:\Users\seren\Downloads\field_icon_circle.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

// GameField Variants
note group Note5
{
  attr Bounds = <10,420,460,540>;
}

// Gamefield Widgets
note group Note6
{
  attr Bounds = <240,140,460,410>;
}

// Fonts, Bitmaps and Colors
note group Note7
{
  attr Bounds = <470,140,919,410>;
}

// Autoobjects
note group Note8
{
  attr Bounds = <470,420,920,540>;
}

$rect <710,190,910,230>
$output false
const color Peach = #E6B794FF;

// Color Scheme
// 
// #E6B794 Peach
// #B8DDD6 Mint
// #E0EBE5 Seafoam Green
// #AD9787 Nude
// #FFFFFF White
note legend Note4
{
  attr Bounds = <999,550,1229,710>;
}

$rect <710,230,910,270>
$output false
const color Mint = #B8DDD6FF;

$rect <710,270,910,310>
$output false
const color SeafoamGreen = #E0EBE5FF;

$rect <710,310,910,350>
$output false
const color Nude = #AD9787FF;

$rect <710,350,910,390>
$output false
const color White = #FFFFFFFF;

$rect <700,450,900,490>
$output false
autoobject Views::Image field_icon_time
{
  preset Bounds = <0,0,50,50>;
  preset Color = Game::Nude;
  preset FrameNumber = 13;
  preset Bitmap = Resources::SymbolIconsMedium;
}

$rect <490,330,690,370>
$output false
autoobject WidgetSet::PushButtonConfig PushButtonConfig
{
  preset LabelColorActive = Game::White;
  preset LabelColorFocused = Game::White;
  preset LabelColorDisabled = Game::White;
  preset LabelColorDefault = Game::White;
  preset IconTintActive = Game::Peach;
  preset IconTintFocused = Game::Peach;
  preset IconTintDisabled = Game::Peach;
  preset IconTintDefault = Game::Peach;
  preset LabelFont = Resources::FontSmall;
  preset FaceTintActive = Game::Peach;
  preset FaceTintFocused = Game::Peach;
  preset FaceTintDisabled = Game::Peach;
  preset FaceTintDefault = Game::Peach;
  preset FaceActive = WidgetSet::PushButtonSmall;
  preset FaceFocused = WidgetSet::PushButtonSmall;
  preset FaceDisabled = WidgetSet::PushButtonSmall;
  preset FaceDefault = WidgetSet::PushButtonSmall;
}

$rect <250,220,450,260>
$output false
class Players
{
  $rect <40,40,240,80>
  property string Name = "P1";

  $rect <40,80,240,120>
  onset Name
  {
    // The value doesn't change - nothing to do.
    if ( pure Name == value )
      return;

    // Remember the property's new value.
    pure Name = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <40,120,240,160>
  onget Name
  {
    return pure Name;
  }

  $rect <260,40,460,80>
  property string Icon = "X";

  $rect <260,80,460,120>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <260,120,460,160>
  onget Icon
  {
    return pure Icon;
  }

  $rect <40,180,240,220>
  property int32 Value;

  $rect <40,220,240,260>
  onset Value
  {
    // The value doesn't change - nothing to do.
    if ( pure Value == value )
      return;

    // Remember the property's new value.
    pure Value = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <40,260,240,300>
  onget Value
  {
    return pure Value;
  }

  $rect <270,180,470,220>
  property int32 TotalWins;

  $rect <270,220,470,260>
  onset TotalWins
  {
    // The value doesn't change - nothing to do.
    if ( pure TotalWins == value )
      return;

    // Remember the property's new value.
    pure TotalWins = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <270,260,470,300>
  onget TotalWins
  {
    return pure TotalWins;
  }
}

$rect <20,180,220,220>
$output false
class GameTitle : Core::Group
{
  $rect <0,340,200,380>
  inherited property Bounds = <0,0,240,320>;

  $rect <0,450,200,490>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,410,200,450>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // GameTitle Dialog will be dismissed onTouch, and onEnter the Screensaver will \
  // start
  note legend Note
  {
    attr Bounds = <270,100,790,320>;
  }

  $rect <270,40,470,80>
  slot smDismiss
  {
    //Text.Bounds = <0,10,240,52>;
    //Rectangle.Bounds = <0,10,240,52>;

    // Bounds = <0,0,240,52>

    //if ( IsDialog(false))
     // Owner.DismissDialog( this, null, null, null, null, null, false );
  }

  $rect <270,0,470,40>
  $output true
  object Core::Timer Timer
  {
    preset OnTrigger = smDismiss;
    preset Period = 0;
    preset Begin = 5000;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <240,0>;
    preset Point2 = <240,320>;
    preset Point1 = <0,320>;
    preset OnPress = smDismiss;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = Game::White;
  }

  $rect <20,20,160,60>
  object Views::Text vSubtitle
  {
    preset Bounds = <39,177,202,255>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertTop];
    preset String = "Subtitle";
    preset Font = Resources::FontSmall;
    preset Color = Game::Mint;
  }

  $rect <20,20,160,60>
  object Views::Text vTitle
  {
    preset Bounds = <39,64,213,165>;
    preset AutoSize = false;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertBottom];
    preset String = "Title";
    preset Font = Resources::FontLarge;
    preset Color = Game::Mint;
  }

  $rect <279,340,479,380>
  property string Title;

  $rect <279,380,479,420>
  onset Title
  {
    // The value doesn't change - nothing to do.
    if ( pure Title == value )
      return;

    // Remember the property's new value.
    pure Title = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.

    vTitle.String = Title;
  }

  $rect <279,420,479,460>
  onget Title
  {
    return pure Title;
  }

  $rect <510,340,710,380>
  property string Subtitle;

  $rect <510,380,710,420>
  onset Subtitle
  {
    // The value doesn't change - nothing to do.
    if ( pure Subtitle == value )
      return;

    // Remember the property's new value.
    pure Subtitle = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.

    vSubtitle.String = Subtitle;
  }

  $rect <510,420,710,460>
  onget Subtitle
  {
    return pure Subtitle;
  }

  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateLayout 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder RemoveAll 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder Note 1
}

// The small version of the default font resource. The resource is using 'Roboto' \
// TrueType font with 18 pixel height.
$rect <480,370,700,410>
$output false
resource Resources::Font FontSmall
{
  attr fontname FontName = Roboto;
  attr fontheight Height = 14;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

$rect <250,270,450,310>
$output false
class GameResult
{
  $rect <-561,35,-361,75>
  property int32 Player1;

  $rect <-561,75,-361,115>
  onset Player1
  {
    // The value doesn't change - nothing to do.
    if ( pure Player1 == value )
      return;

    // Remember the property's new value.
    pure Player1 = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <-561,115,-361,155>
  onget Player1
  {
    return pure Player1;
  }

  $rect <-560,160,-360,200>
  property int32 Player2;

  $rect <-560,200,-360,240>
  onset Player2
  {
    // The value doesn't change - nothing to do.
    if ( pure Player2 == value )
      return;

    // Remember the property's new value.
    pure Player2 = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <-560,240,-360,280>
  onget Player2
  {
    return pure Player2;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <250,310,450,350>
$output false
class PushButton : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,116,35>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your button design, you have surely added some new views
      to your button. In the below code you should update the properties of
      these views. For example, when your button has two images to appear
      exclusively for released and pressed button state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the button, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the button
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your button component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the button. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color = Game::White;
      Border.Color     = #7E7A75FF;
      Border.Width     = 2;
    }
                       
    else if ( isPressed )
    {
      Background.Color = Game::Nude;
      Border.Color     = Game::White;
      Border.Width     = 2;
      Rectangle.Visible = true;
    }

    else if ( isSelected )
    {
      //Background.Color = Game::Nude;
      Border.Color     = Game::White;
      Border.Width     = 2;
      Rectangle.Visible = false;
    }

    // Enabled but not pressed nor selected.
    else
    {
      //Background.Color = #FFFFFFFF;
      Border.Color     = Game::White;
      Border.Width     = 1;
      Rectangle.Visible = false;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
  }

  // To do:
  // 
  // - Adjust the visible size of your button (the thick blue border). This will \
  // be the button's default size.
  // - Resize the member 'TouchHandler' so it still fills the button's new area.
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your button.
  // - According to your desired button design add and configure new views (e.g. \
  // an image view to show the icon or a text view to show the button caption, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the button's current state.
  // - You can also add and configure animation effects to your button. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your button.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the button itself is resized.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // button to be activated with key other than the 'Enter' key.
  // - Alternatively remove the members 'KeyHandler' and 'onPressKey' if you don't \
  // want any keyboard handling.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your button. One property \
  // for every button specific setting (e.g. 'Caption', 'Icon', 'Color', 'Font', \
  // ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your button where \
  // the icon is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,370,990,750>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,116,35>;
    preset Color = Game::Nude;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,116,35>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,35>;
    preset Point3 = <116,35>;
    preset Point2 = <116,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <210,0,410,40>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,116,35>;
    preset String = "Reset";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,116,35>;
    preset Color = #3737374D;
    preset Visible = false;
  }

  $rect <440,0,640,40>
  property string BtnText;

  $rect <440,40,640,80>
  onset BtnText
  {
    // The value doesn't change - nothing to do.
    if ( pure BtnText == value )
      return;

    // Remember the property's new value.
    pure BtnText = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.

    Text.String = BtnText;
  }

  $rect <440,80,640,120>
  onget BtnText
  {
    return pure BtnText;
  }
}
